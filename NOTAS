/*
Definir estrutura t_list:
    data  -> ponteiro para valor genérico
    next  -> ponteiro para próximo nó

Função add_elem(data, size):
    Alocar memória para novo nó
    Alocar memória para o valor do nó com tamanho 'size'
    Copiar byte a byte o valor de 'data' para 'node->data'
    next do nó = NULL
    Retornar nó

Função append(begin, data, size):
    Criar novo nó usando add_elem(data, size)
    Se lista estiver vazia:
        begin = novo nó
    Senão:
        Percorrer a lista até o último nó
        last->next = novo nó

Função run_list(begin):
    Enquanto begin não for NULL:
        Imprimir valor do nó
        Se existir next, imprimir separador (ex: "->")
        Avançar para o próximo nó

Função free_list(begin):
    Enquanto begin não for NULL:
        Guardar begin->next em tmp
        Liberar memória de begin->data
        Liberar memória do nó begin
        Avançar begin = tmp

Função ft_atoi(str):
    Converter string para inteiro
    Retornar inteiro

Função main(argc, argv):
    Se argc < 2:
        Imprimir mensagem de uso
        Terminar

    lista = NULL
    Para cada argumento argv[i]:
        val = ft_atoi(argv[i])
        append(&lista, &val, sizeof(int))

    run_list(lista)
    free_list(lista)
*/

int ft_isNum(char *n)
{
    int i = 0;
    if(!n)
        return 0;
    if(n[0] == '-' || n[0] == '+')
        i++;
    while(n[i])
    {
        if(n[i] >= '0' && n[i] <= '9')
            return 1;
        i++;
    }
    return 0;
}


void ft_sorted_list_insert(t_list **begin_list, void *data, int (*cmp)())
{
    t_list *new = add_elem(data, sizeof(int));
    t_list *node = *begin_list;
    
    if(!*begin_list || cmp (data, node->data) < 0) // o meu primeiro numero e inferior
    {
        new->next = *begin_list;
        *begin_list =  new;
        return;   
    }
    while(node->next && cmp(data, node->next->data) >= 0)
    {
        node = node->next;
    }
    
    new->next = node->next;
    node->next = new;
}

int main(int ac, char **av)
{
    if(ac < 2)
        return 1;   
    
    int i = 1; 
    int *d = malloc(sizeof(int));

    *d = 10;
    
    t_list *list = NULL;
    while(i < ac)
    {
        if(!ft_isNum(av[i]))
        {
            printf("POE NUMEROS CRLHS!");
            return 1;
        }
        int val = ft_atoi(av[i]);
        ft_sorted_list_insert(&list, &val, cmp);
        i++;    
    }
    run_list(list);
    printf("\n");
    free_list(&list);
    return 0;
}

/*
Exercício Base: Ordenar usando duas pilhas

Objetivo:
Dada uma lista de números passados via argv, você deve organizar os números em ordem crescente usando apenas duas pilhas (stack_a e stack_b) e operações limitadas:

sa / sb – troca os dois primeiros elementos da pilha.

pa / pb – move o topo de uma pilha para a outra.

ra / rb – rotaciona a pilha (o topo vai para o final).

rra / rrb – rotaciona a pilha ao contrário (o final vai para o topo).

Estrutura sugerida:

typedef struct s_list
{
    int data;
    struct s_list *next;
} t_list;


stack_a inicia com todos os números da entrada (argv).

stack_b inicia vazia.

Passos do exercício:

Criar stack_a com os números passados.

Criar stack_b vazia.

Implementar funções básicas:

push(t_list **from, t_list **to) – equivalente a pa ou pb.

swap(t_list **stack) – equivalente a sa ou sb.

rotate(t_list **stack) – equivalente a ra ou rb.

reverse_rotate(t_list **stack) – equivalente a rra ou rrb.

Criar um algoritmo que mova elementos de stack_a para stack_b e depois volte para stack_a em ordem crescente, usando as funções acima.

Dicas:

Comece simples: só tente ordenar 3 números. Depois passe para 5, depois N.

Use ft_sorted_list_insert como referência para decidir onde colocar um número na outra pilha.

Tente escrever uma função is_sorted(stack) para testar se stack_a já está ordenada.

Se você quiser, eu posso te escrever um esqueleto em C com duas pilhas e funções de movimentação (push, swap, rotate) para você começar a implementar o algoritmo do Push Swap.*/
    

1️⃣ Operações de swap

sa → troca os dois primeiros de A 1

sb → troca os dois primeiros de B

ss → sa + sb ao mesmo tempo

2️⃣ Operações de push

pa → topo de B para A

pb → topo de A para B

3️⃣ Operações de rotate

ra → primeiro de A vai para o fim 1 

rb → primeiro de B vai para o fim

rr → ra + rb ao mesmo tempo

4️⃣ Operações de reverse rotate

rra → último de A vai para o topo

rrb → último de B vai para o topo

rrr → rra + rrb ao mesmo tempo

--------------------------------------

#SAGRADO#

a ft_shortbreak e a funcao sagrada para conseguir utilizar os meus sort de forma mais eficiente
    - a shortbreak procura a posicao do meu valor MAx ou MIn que estou a procura
        - apos encontrar a posicao da mesma ou + proximo do meu inicio ou mais longe
                    - da uns dos comandos ou troca os primeiros 2 ! ou manda os ultimos 2 para o inicio
com isso a minhas sort3 ficou melhor !

#ANTES-
void ft_sort3(t_list **stacka) 
{
    if(!stacka || ft_list_size(*stacka) < 3) // condicao principal
        return;
    if(ft_is_sorted(*stacka) == 0)
        return;
    t_list *node;   
    int first;
    int second;
    int third;
     
    node = *stacka;
    first = *(int*)node->data;
    second = *(int*)node->next->data;
    third= *(int*)node->next->next->data;
    if(first > second && second < third && first > third) // 312
        ft_ra(stacka);
    else if(first < second && second > third && first > third) //231 x
        ft_rra(stacka);
    else if(first > second && second < third && third > first) //213
        ft_sa(stacka);
    else if(first > second && second > third) //321 x
        (ft_ra(stacka), ft_sa(stacka));
    else if(first < second && second > third && first < third) //132 x
        (ft_sa(stacka), ft_ra(stacka));
}

#DEPOIS
void ft_sort3(t_list **stacka, t_list **stackb)
{
    if(!stacka || ft_list_size(*stacka) < 2)
        return;
    if(ft_is_sorted(*stacka) == 0)
        return;
    t_list *node;
    t_list *max;

    max = *stacka;
    node = *stacka;
    while(node)
    {
        if(*(int*)max->data > *(int*)node->data)
            max = node;
        node = node->next;
    }
    ft_shortbreak(stacka, max, ft_list_size(*stacka));
    ft_pb(stacka, stackb);
    ft_sort2(stacka);
    ft_pa(stacka, stackb);
}

- IMPLEMENTACAO DO MEU SORT4
    porque?
        - pq a minha sort5 ja estava grande kkkk e fui na preguica , pq se n, era so fazer um sort2
            aos valores passados na stackb para depois sim mandar eles para a minha stacka
            - so que isso ia pedir mais condicoes entao modulei a sort4.
- criacao da sort4 (logica)

void ft_sort4(t_list **stacka, t_list **stackb)
{
    if(!stacka || ft_list_size(*stacka) < 4) // nul ou n tem o numero de elem.
        return;
    if(ft_is_sorted(*stacka) == 0) // ja esta sorted
        return;
    t_list *tmp = *stacka; // refernecia
    t_list *max = *stacka; // valores max
    
    while(tmp) // percorre a lista a procura do mair valor!
    {
        if(*(int*)max->data > *(int*)tmp->data)
            max = tmp; // meu novo valor maximo.
        tmp = tmp->next; // atualiza a lista.
    }
    ft_shortbreak(stacka, max, ft_list_size(*stacka));
    ft_pb(stacka, stackb);
    ft_sort3(stacka, stackb);
    ft_pa(stacka, stackb);


    -mesma logica utiliza!
        - verificao de NULL e de valores
        - verificao da is_sorted
        - apos isso a mesma logica:
        
        - dois valores tipo t_list! um max/min que vai ter o msm valor da minha tmp
            - pois serve somente para comparacao
        - um loop que percorre com uma condicao de comparacao de valores
            - caso houver um valor maior/inferior ao max/min -- atualiza o mesmo
        - apos encontrar - manda shortbreak ! -- diz me onde esta -- faz o calculo para ou usar RA ou RRA
        - mandar entao o valor prentendio para stackb
        - dar sort pretendido de acordo com o numero restante -- se sobrar 3 da sort3 etc...
        - mandar de volta o valor da stack para a stacka.
         

#CONDICOES DE SEGURANCA
    - primeiro verificar se o meu valor e NULL ! !stack 
        ou 
    - verificar se o tamanho esta de acordo com o sort ! 
        - ft_listsize!! < ao valor do sort(ex para sort3 o valor tem de ser == 3 se for < == return)
    - apos isso verificar se ja esta sorted!
        ft_isorted 
            - simplesmente faz um loop e ve se ha um valor *(int*)stacka->data > *(int)stacka->next->data
                se for verdade logo n esta sorted ... se ao chegar ao fim , n houve quebra de condicao 
                    - e true -- sorted.
